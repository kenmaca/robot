/* Written by Kevin Alexander Lee

    This is an implementation of NXT robot localization using probability and
    particle filters.

    Using the grid based map accompanying the code, the robot which initially
    has no information about its coordinate position will be able to locate itself
    and move to a specific target and destination.
  
    The NXT robot uses aspects of particle filters and probability sensing to
    determine which position it is likely at.
*/

// headings
#define NORTH 100
#define EAST 101
#define SOUTH 102
#define WEST 103
#define NORTHEAST 1000
#define SOUTHEAST 1001
#define SOUTHWEST 1002
#define NORTHWEST 1003

// colors
#define BLACK 
#define GREEN
#define BLUE
#define WHITE
#define YELLOW
#define RED

// file related macros
#define FILENAME "mapdata.txt"
#define READSIZE 10

// function like macro to convert characters from files to the corresponding
// int value.
#define ASCII_TO_INT(a) a-48

// macros for the map dimensions. based on yellow grid intersections
#define GWIDTH 3
#define GHEIGHT 5

/* macros for probability sensing

    THRESHOLD - a decimal value in (0,1). Determines when a particle is 
        likely enough to be the robot's position

    MATCH - a decimal value in (0,1). How much to affect the probability
        when a particle's data matches the robot's surroundings, should be 
        greater than MISMATCH

    MISMATCH - a decimal value in (0,1). How much to affect the probability 
        when a particle's data does not match the robot's surroundings, 
        should be less than MATCH
*/
#define THRESHOLD
#define MATCH
#define MISMATCH

// movement
#define SPEED 20
#define WHEEL_RATIO 0.03761
#define SENSOR_PIVOT_RATIO 0.08847781
#define WHEEL_PIVOT_RATIO 0.11301644
#define BREAK true
#define LEFT_90 90
#define RIGHT_90 -90
#define ST_P 45

/* Represents a single particle.

    Each particle has a coordinate given by x and y and also a direction.

    The probability attached to a particle is the likelihood of it being the
    actual position and heading of the robot. This is updated based on the
    robot's surroundings.
*/
struct particle {
    int x;
    int y;
    int theta;

    // weight of a particle representing probability
    float prob;
};

/* Represents an interesection (yellow square) on the grid.

    Holds data on the surroundings of the intersection, namely coloured(or white)
    squares to the NE, SE, SW, NW of the interesection.
   
    Note that the directions are by default in terms of compass directions.
    When given a heading, the directions will change relative to the heading.
*/
struct intersection {
    int NE;
    int SE;
    int SW;
    int NW;
};

/* Samples five times from the color sensor and returns the most frequently
    occurring color.
*/
int colour() {
    char scans, i, col, n; 


    n = 5;
    int pitch [6] = {233, 466, 932, 1865, 3729, 7458};

    SetSensorColorFull(IN_3);
    for (i=0; i < n; i++) {
        scans += SENSOR_3;
    }

    col =  scans / n;
    PlayTone(pitch[col], 400);
    return col;
}

/* Drives the robot distance centimeters. If distance is negative, the robot
   is moved backwards. The left wheel is moved forward if left is specified
   as 1, backwards as -1, and stationary as 0. Similarly for the right wheel.
   Using negative distance with a negative left/right toggle will move
   forwards (but don't do this).
   
   @param distance The centimeters that this robot should travel.
   @param left The direction that the left wheel should move in (-1, 0, or 1)
   @param right The direction that the right wheel should move in (-1, 0, or 1)
*/
sub drive(long distance, char left, char right) {

    // both forward
    if ((left > 0) && (right > 0)) {
        RotateMotorEx(
            OUT_BC, SPEED, 
            distance / WHEEL_RATIO,
            0, true, BREAK
        );

    // both backward
    } else if ((left < 0) && (right < 0)) {
        RotateMotorEx(
            OUT_BC, SPEED, 
            distance / WHEEL_RATIO,
            0, true, BREAK
        );

    // left forward, right backwards
    } else if ((left > 0) && (right < 0)) {
        RotateMotorEx(
            OUT_BC, SPEED, 
            distance / WHEEL_RATIO,
            100, true, BREAK
        );

    // left backwards, right forwards
    } else if ((left < 0) && (right > 0)) {
        RotateMotorEx(
            OUT_BC, SPEED, 
            distance / WHEEL_RATIO,
            -100, true, BREAK
        );

    // left forward only
    } else if (left > 0) {
        RotateMotorEx(
            OUT_C, SPEED,
            distance / WHEEL_RATIO,
            0, false, BREAK
        );
      
    // left backwards only
    } else if (left < 0) {
        RotateMotorEx(
            OUT_C, SPEED,
            left * distance / WHEEL_RATIO,
            0, false, BREAK
        );

    // right forward only
    } else if (right > 0) {
        RotateMotorEx(
            OUT_B, SPEED,
            distance / WHEEL_RATIO,
            0, false, BREAK
        );

    // right backwards only
    } else if (right < 0) {
        RotateMotorEx(
            OUT_B, SPEED,
            right * distance / WHEEL_RATIO,
            0, false, BREAK
        );
    }
}

/* Pivots degrees degrees the robot on the sensor as its axis if mode is set
   to 0, or forwards pivot on a single wheel (depending on the degree) if mode
   is set to 1, or backwards pivot on a single wheel (depending on the degree)
   if mode is set to -1.
   
   @param degrees The number of degrees to pivot this robot is heading to.
   @param mode The mode (-1, 0, or 1)
*/
sub rotate(long degrees, char mode) {

    // pivot left on sensor (left backwards, right forward)
    if ((degrees > 0) && (mode == 0)) {
        drive(degrees * SENSOR_PIVOT_RATIO, -1, 1);

    // pivot right on sensor (left forward, right backwards)
    } else if ((degrees < 0) && (mode == 0)) {
        drive(degrees * SENSOR_PIVOT_RATIO, 1, -1);

    // pivot left on left wheel (right wheel forward)
    } else if ((degrees > 0) && (mode == 1)) {
        drive(degrees * WHEEL_PIVOT_RATIO, 0, 1);

    // pivot right on right wheel (left wheel forward)
    } else if ((degrees < 0) && (mode == 1)) {
        drive((-1) * degrees * WHEEL_PIVOT_RATIO, 1, 0);

    // pivot left on right wheel (left wheel backwards)
    } else if ((degrees > 0) && (mode == -1)) {
        drive(degrees * WHEEL_PIVOT_RATIO, -1, 0);

    // pivot right on left wheel (right wheel backwards)
    } else if ((degrees < 0) && (mode == -1)) {
        drive((-1) * degrees * WHEEL_PIVOT_RATIO, 0, -1);
    }
}

/* Subroutine which moves the robot forward from one intersection to the next
*/
sub move_robot() {
    ////////////////////////////////////////////////////////////////////////////
    //  TO DO:
    //
    //  Complete this subroutine.
    //  Your robot will need to nagivates its way from one interesection to the
    //  next. If it reaches a red boundary, it will do a 180 degree turn and
    //  return to the previous intersection facing in the opposite direction.
    //
    //  You may need to account for motor "noise" as your robot will not always
    //  make turns perfectly and go straight forward each time.
    //
    ////////////////////////////////////////////////////////////////////////////

}

/* Scans the surroundings of the robot, takes readings of the colour of 
    the 4 squares surrounding the intersection, and returns an intersection
    variable which holds the data.

    @returns struct
*/
intersection scan_surroundings() {
    intersection rsense;
    ////////////////////////////////////////////////////////////////////////////
    // TO DO:
    //
    // Implement a function in which the robot will scan the colour of the
    // surrounding squares at an interesection.
    // It will use the colour sensor to take readings from all four squares
    // in each of the NE, SE, SW, NW directions relative to the forward facing
    // direction of the robot.
    //
    ////////////////////////////////////////////////////////////////////////////
    rotate(RIGHT_90, 1);
    rsense.NE = colour();
    rotate(LEFT_90, -1);
    rotate(LEFT_90, -1);
    rsense.SE = colour();
    rotate(RIGHT_90, 1);
    rotate(RIGHT_90, -1);
    rsense.SW = colour();
    rotate(LEFT_90, 1);
    rotate(LEFT_90, 1);
    rsense.NW = colour();
    rotate(RIGHT_90, -1);
    return rsense;
}

/* Given the original heading and a new heading, turns the robot to reflect
    the new heading

    This subroutine is used after the robot knows it's position
*/
sub change_direction(int orig, int new) {
    ////////////////////////////////////////////////////////////////////////////
    // TO DO:
    //
    // Implement each of the turns specified below.
    //
    ////////////////////////////////////////////////////////////////////////////

    int change = new - orig;
    switch (change) {
        case 3:
        case -1:
            // turn left 90 degrees
            break;
        
        case -3:
        case 1:
            // turn right 90 degrees
            break;
        
        case 2:
            // 180 degree turn
            break;
    }
}
          /**
task to_road() {
    while((colour() != BLACK) || (colour() != YELLOW)) {
        OnRev(OUT_BC);
    }
    Off(OUT_BC);
}

task trace() {
    long step = 2.0;
    black_count = 0;
    
    while(colour() == BLACK){
      black_count += 1;
      drive(step, 1, 1);
      wait(500);
    }
    align();
    //black_count = 0; //reset black count incase robot gets off the road
    drive(step,1,1);
    if(colour() == WHITE) {
      align();
    }

    black_count = 0;
    while(colour() == BLACK){
      black_count += 1;
      drive(step, 1, 1);
      wait(500);
    }
    
}


sub align() {
      rotate(90, 0);
      dir = 1; //means you turned left 
      drive(step, 1, 1);
      if(colour() != BLACK) {
        rotate(-180, 0);
        dir = -1; //means you turned right
        drive(step*2, 1, 1);
      }
      if(black_count < 3) {
        drive(step*2, 1, 1); //try 2 or 3 steps since you're not coming in too steep
        rotate(20*dir*-1,0);
      }
      else if (black_count >=3 && black_count <=5) {
        drive(step, 1, 1);
        rotate(45*dir*-1,0);
      }

      else{
        drive(step*2, 1, 1);
        rotate(70*dir*-1,0);
      }
}
            **/

/* Given a start coordinate, finish coordinate, and a heading, this function
    moves the robot from the start to finish.
   
    The coordinates given are in terms of index in the map array. The x and y
    coordinates need to be extracted from that index.
   
    After the robot has finished moving, the current heading of the robot is
    returned.
   
    This function is used after the robot knows it's own position.
*/
int move_to(int s, int f, int h) {
    int sx, sy, fx, fy, tx, ty;
    int heading;
    
    // extract coordinates from given information
    sx = s / GHEIGHT;
    sy = s % GHEIGHT;
    fx = f / GHEIGHT;
    fy = f % GHEIGHT;
    
    // calculate how far to go in manhatten distances
    tx = fx - sx;
    ty = fy - sy;
    heading = h;

    ///////////////////////////////////////////////////////////////////////////
    // TO DO:
    //
    // Move the robot from the starting point described by (sx, sy) to (fx, fy)
    // Be sure to keep track of the direction the robot is facing when it
    // makes turns.
    //
    ////////////////////////////////////////////////////////////////////////////

    return heading;
}

/* This function takes a particle and returns an updated particle after moving

    To "move" a particle is to move it forward in the direction of the particle.
    We move these particles in the same way we would move the robot.
   
    Upon reaching a boundary, the particle is turned 180 degrees around.
*/
particle move(particle p) {
    ///////////////////////////////////////////////////////////////////////
    // TO DO:
    //
    // Move particle p forward one interesection in the direction it is
    // facing.
    // Similar to the robot's behaviour, if a particle reaches the end of
    // the map, it turns in the opposite direction and returns to the
    // previous intersection it was at.
    //
    ///////////////////////////////////////////////////////////////////////

    return p;
}

/* This function returns data on interesection surroundings for particles.

    Based on the map data array, we want the colour of the square at the given x
    and y coordinates in direction dir which is one of NE, SE, SW, NW.
   
    Take note that the heading given will change the percieved directions.
    For example, facing north, NE in terms of compass directions is northeast.
    Facing south however, NE in terms of compass directions is southwest.
   
    Because the robot does not know it's own heading, the particles must reflect
    this by using sensing relative to heading.
*/
int sense(intersection map[], int x, int y, int dir, int heading) {
    ////////////////////////////////////////////////////////////////////////////
    // TO DO:
    //
    // Implement the function which checks the surroundings of the particle at
    // (x, y) facing the direction given by heading.
    //
    // The data you need to determine the particle's surroundings is given by
    // the map data array.
    //
    // The integer returned is the
    // colour of the square in the direction of dir which is one of NE, SE, SW,
    // or NW.
    // Keep in mind that the direction is relative to the heading as mentioned
    // in the function description.
    //
    ////////////////////////////////////////////////////////////////////////////

    // you may need to remove this
    return -1;
}

/* The main task which initializes data and executes the update loop for 
    the particle filters.
*/
task main() {

    // test run

    /*while(true){
        rotate(90, 0);
    } */
    //drive(10,1,1);
    //rotate(-90, 1);
    //rotate(90, -1);
    scan_surroundings();
    Stop(true);

    // holds map data
    intersection map [GWIDTH *GHEIGHT];
     
    // holds x y and theta of the best guess at robot's position
    int guess[3];

    // holds the prob that the robot is at guess
    float robp = 0;

    // holds data about the robot's surroundings
    intersection rsense;

    // list of particles
    particle list[GWIDTH*GHEIGHT*4];

    // holds data on a particle's surroundings
    int psense[4];

    // variables for loop counters
    int i, j;

    // keeps track of how many of a particle's surroundings match the robot's
    int hits, misses;
    float maxprob, totalprob;

    // variables for file descriptors and characters
    byte fd, charat;
    string line;

    // records the target and destination coordinates for use after finding
    // the robot's position
    int target, dest;
     
    // sensor initialization
    SetSensorColorFull(IN_1);

    // initialize the particle list, each coordinate has 4 particles, one
    // for each direction
    for (i = 0; i < GWIDTH * GHEIGHT * 4; i = i + 4) {
        list[i].x = (i / 4) % GWIDTH;
        list[i].y = i / (4 * GWIDTH);
        list[i].theta = NORTH;
        list[i].prob = 1.0 / (GWIDTH * GHEIGHT * 4);
        list[i+1].x = (i / 4) % GWIDTH;
        list[i+1].y = i / (4 * GWIDTH);
        list[i+1].theta = SOUTH;
        list[i+1].prob = 1.0 / (GWIDTH * GHEIGHT * 4);
        list[i+2].x = (i / 4) % GWIDTH;
        list[i+2].y = i / (4 * GWIDTH);
        list[i+2].theta = EAST;
        list[i+2].prob = 1.0 / (GWIDTH * GHEIGHT * 4);
        list[i+3].x = (i / 4) % GWIDTH;
        list[i+3].y = i / (4 * GWIDTH);
        list[i+3].theta = WEST;
        list[i+3].prob = 1.0 / (GWIDTH * GHEIGHT * 4);
    }
   
    /* Initialize the map and target from file

        The format of the file:
        - one line per intersection containing 4 integers seperated by spaces
            these integers represent NE SE SW NW respectively

        - the order of the intersections is rows top to bottom then columns
            left to right

        - after all the intersection data there are two lines with 2 integers
            each. this describes the target and destination that the robot must
            move to after finding its position
            
        Colour values are based on NXC colour sensor constants
      
        Array format:
            - indices are obtained using the formula i = GHEIGHT*x + y
        
            - each index contains an interesction element that holds 
                information about it's surroundings
    */
   
    fd = fopen(FILENAME, "r");
    
    // read as many lines as there are squares on the grid
    for (i = 0; i < GWIDTH * GHEIGHT; i++) {
        fgets(line, READSIZE, fd);

        // parse each line into the coresponding directions and store them in
        // the map data array
        for (j = 0; j < 7; j = j + 2){
            charat = StrIndex(line, j);
            switch (j){
                case 0:
                    map[i].NE = ASCII_TO_INT(charat);
                    break;

                case 2:
                    map[i].SE = ASCII_TO_INT(charat);
                    break;

                case 4:
                    map[i].SW = ASCII_TO_INT(charat);
                    break;

                case 6:
                    map[i].NW = ASCII_TO_INT(charat);
                    break;
            }
        }
    }

    // read information about the target which should be following the map data 
    fgets(line, READSIZE, fd);
    charat = StrIndex(line,0);
    target = ASCII_TO_INT(charat);

    // add x coordinate calculation
    target = target*GHEIGHT;
    charat = StrIndex(line,2);

    // add y coordinate
    target = target + ASCII_TO_INT(charat);
        
    // read information about the destination which sould be following the 
    // target data
    fgets(line, READSIZE, fd);
    charat = StrIndex(line,0);
    dest = ASCII_TO_INT(charat);

    // add x coordinate calculation
    dest = dest*GHEIGHT;
    charat = StrIndex(line,2);

    // add y coordinate
    dest = dest + ASCII_TO_INT(charat);

    // file reading finished
    fclose(fd);

    /* Main execution loop for particle filter

        How particle filters work:

        Normally we would have a list of particles initilalized with random
        coordinates and headings.

        At each iteration of the loop, we move the robot and the particles.
        Surroundings for both are examined and compared.

        Particles which have surroundings that seem close to the robots are given
        larger weights compared to those that don't.

        We then choose from the particles in a way that the particles with higher
        weights are likley to remain, while particles with smaller weights are
        eliminated. This is called resampling.

        After several iterations, we would have a group of particles which is
        very likley to represent the robot's actual position.

        How this implementation works:

        We have simplified the large possibility of coordinates to a grid.

        === Particle List ===
        For each intersection on the grid map, we have four particles.
        One for each of north, east, south, and west, which the robot could be
        facing since it will move vertically and horizontally.
        These are all the possible starting positions and headings the robot could
        have.

        === Updating weights ===
        Each iteration we reasign the particle weights.
        We move the robot, and also the particles.
        The surroundings, being the four coloured squares around the intersection
        are checked. The robot's and particles surroundings are compared and the
        weights are changed based on whether they match or not.

        === Resampling ==
        Take note that we do NOT do resampling in this implementation.
        Instead we have a probability threshold that a particle must pass to be
        accepted as the actual position of the robot.
    */

    ////////////////////////////////////////////////////////////////////////////
    // TO DO:
    //
    // Write the main particle filter execution loop. It will loop until a
    // particle weight reaches the threshold
    //
    // At each iteration the following steps take place:
    //    - robot checks its surroundings
    //    - each particle checks its surroundings and compares them with the
    //      robot's
    //    - adjust particle weights based on the comparison
    //    - normalize particle weights
    //    - find the best guess of the robot's position
    //    - move the robot and the particles forward to the next intersection
    //
    ////////////////////////////////////////////////////////////////////////////

    /* while (robp < THRESHOLD) {
        Run the update loop until an acceptable probability is obtained
    }
    */
    
    PlayToneEx(Random(1000) + 200, 400, 3, FALSE);

    /* When we are fairly confident about the robot's position, we can move on
        to the task given.

        Once the robot has found where it is, it must head to the target given 
        in the initialization file.

        After picking up the confidential item at the target point it must 
        move to the delivery point given by the destination from the 
        initialization file.
    */

    guess[2] = move_to(guess[0] * GHEIGHT + guess[1], target, guess[2]);
    PlayToneEx(Random(1000) + 200, 400, 3, FALSE);
    move_to(target, dest,guess[2]);
    PlayToneEx(Random(1000) + 200, 400, 3, FALSE);
}
